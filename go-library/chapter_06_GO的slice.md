## slice 切片

Go语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片("动态数组"),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大
切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由
从概念上面来说slice像一个结构体，这个结构体包含了三个元素：
 1. 指针,指向数组中slice指定的开始位置
 2. 长度，即slice的长度
 3. 最大长度，也就是slice开始位置到数组的最后位置的长度

1. slice的定义
 - 第一种
   `var s1 []int`
 - 第二种
   `s := arr[startIndex:endIndex] `  
> 可以开始与结束都可以根据需求进行省略

 - 第三种
  `s := make([]int,3,10)`
> 第二个参数,表示存放的元素个数,第三个叁数,表示空间的大小
> 一个切片在未初始化之前默认为 nil，长度为 0

2. slice的简单使用

```
    package main

    import "fmt"

    func main() {
    	/*定义一个简单切片*/
    	var s1 []int
    	/*截取数组成为切片,使有起始与结束*/
    	a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    	s2 := a[9]
    	s3 := a[4:6]
    	s4 := a[3:]
    	s5 := a[:6]
    	s6 := a[:]
    	/*make方法创建 第一个参数是 类型,第二个当前存放的元素个数,第三个分配的空间大小*/
    	s7 := make([]int, 3, 10)

    	fmt.Println(s1)
    	fmt.Println(s2)
    	fmt.Println(s3)
    	fmt.Println(s4)
    	fmt.Println(s5)
    	fmt.Println(s6)
    	fmt.Println(s7)
    	fmt.Printf("%v,%p\n", s7, s7)
    	/*追加*/
    	s7 = append(s7, 1, 2, 3, 4, 5, 6)
    	fmt.Printf("%v,%p\n", s7, s7)
    	/*追加,当超过了设置之好了的空间大小之后,会重新分配一个空间*/
    	s7 = append(s7, 1, 2, 3, 4, 5, 6)
    	fmt.Printf("%v,%p\n", s7, s7)
    	/*slice是指是向地址空间的*/
    	b := []int{1, 2, 3, 4, 5}
    	s8 := b[1:5]
    	s9 := b[1:3]
    	fmt.Println(s8, s9)
    	s8[0] = 111
    	fmt.Println(s8, s9)
    	s9 = append(s9, 5, 5, 5, 5, 5, 5, 5, 5, 5)
    	s8[1] = 222
    	fmt.Println(s8, s9)
    	/*copy, 把后面的参数复制前一个参数上*/
    	s11 := []int{1, 2, 3, 4, 5, 6, 7}
    	s12 := []int{11, 21, 31}
    	copy(s11, s12)
    	fmt.Println(s11)
    	s13 := []int{1, 2, 3, 4}
    	s14 := []int{11, 12, 14, 15, 15, 19}
    	copy(s13, s14)
    	fmt.Println(s13)
    }
```

结果：

```
    []
    10
    [5 6]
    [4 5 6 7 8 9 10]
    [1 2 3 4 5 6]
    [1 2 3 4 5 6 7 8 9 10]
    [0 0 0]
    [0 0 0],0xc04200e230
    [0 0 0 1 2 3 4 5 6],0xc04200e230
    [0 0 0 1 2 3 4 5 6 1 2 3 4 5 6],0xc042018140
    [2 3 4 5] [2 3]
    [111 3 4 5] [111 3]
    [111 222 4 5] [111 3 5 5 5 5 5 5 5 5 5]
    [11 21 31 4 5 6 7]
    [11 12 14 15]
```
这里我们注意一下,我们的slice指向的的切片的具体的地址空间,如果没有超过其分配的地址大小,如果修改其中一个切片的具体值,修改之后,所以指向该地址空间的值都会发生相应的改变

append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数

append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩 余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原 数组的内容将保持不变；其它引用此数组的slice则不受影响

len() 和 cap() 函数 切片是可索引的，并且可以由 len() 方法获取长度 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少
