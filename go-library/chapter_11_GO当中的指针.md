## 指针

我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。
一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。
`Go` 语言的取地址符是 `&`，放到一个变量前使用就会返回相应变量的内存地址。
做为函数的参数时使用`func P(*pointer)`,表示是声明指针

`var var_name *var_type`

```
var ip *int /*整型指针*/
var fp *float32 /*浮点形指针*/
```

1. 简单示例

```
func main() {
	a := 10
	fmt.Printf("变量地址%x,\n变量指针%p,\n变量的值:%v\n", &a, &a, a)
}
```
结果为:
```
变量地址c0420421d0,
变量指针0xc0420421d0,
变量的值:10
```

> 可以看出,我们的指针只是在变量的地址前面上`0xc`,而且实际上面也是也向的这个变量的实际内存地址


2. 关于指针变量、变量地址、变量值的简单区别

```
/* 声明实际变量 */
b := 20
/*声明int型指针变量*/
var ip *int
/* 指针变量的存储地址 */
ip = &b
fmt.Printf("b 变量的地址为:%x\n", &b)
/*指针变量的存储地址*/
fmt.Printf("ip 指针变量的地址为:%x\n", ip)
/*该指针所对应的值是*/
fmt.Printf("*ip 变量指向的值为:%d\n", *ip)
```
结果为:

```
b 变量的地址为:c042042200
ip 指针变量的地址为:c042042200
*ip 变量指向的值为:20
```
3. 关于指针的与结构的简单使用

```

type name int8
type p struct {
	age int
	ok  bool
	name
}

p1 := p{1, false, 2}
/*声明P2是p1的指针*/
p2 := &p1
/*取值的差异*/
fmt.Println(p1, p1.age, p1.ok, p1.name)
fmt.Println(p2, p2.age, p2.ok, p2.name)
fmt.Println(&p2, (*p2).age, (*p2).ok, (*p2).name)
```
结果为:

```
{1 false 2} 1 false 2
&{1 false 2} 1 false 2
0xc042004030 1 false 2
```
> 能过上面的实例,我们不难发现在来go语言当中指针的实现灵活,可以直接修改变量,不需要进行转变
> 在一般开发当中,指针能为我们解决一大部分的内存开销,所以建议在声明变量的时候,直接使用指针或是使用new来声明
> 获取指针地址在指针变量前加&的方式,结构什么的是使用 new

4. GO当中的空指针
当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。 `nil` 指针也称为空指针。 `nil`在概念上和其它语言的`null、None、nil、NULL`一样，都指代零值或空值。 一个指针变量通常缩写为`ptr`。

空指针判断：
```
/* ptr 不是空指针 */
if(ptr != nil)   
/* ptr 是空指针 */  
if(ptr == nil)    
```
5. 指针数组

```
/*指针数组*/
const MAX int = 5
/*声明一个slice*/
s1 := []int{10, 100, 300, 600, 400}
/*声明一个指针数组*/
var ptr [MAX]*int
/*但是我们需要保存这个数组*/
for i := 0; i < MAX; i++ {
    fmt.Printf("d[%d] = %d\n", i, s1[i])
    /*整数地址赋值给指针数组*/
    ptr[i] = &s1[i]
}
/*输出指针数组*/
for i := 0; i < MAX; i++ {
    /*输出变量的值*/
    fmt.Printf("d[%d] = %d\n", i, *ptr[i])
    /*输出地址*/
    fmt.Printf("d[%d] = %d\n", i, ptr[i])
}
```
结果:
```
d[0] = 10
d[1] = 100
d[2] = 300
d[3] = 600
d[4] = 400
d[0] = 10
d[0] = 825741337248
d[1] = 100
d[1] = 825741337256
d[2] = 300
d[2] = 825741337264
d[3] = 600
d[3] = 825741337272
d[4] = 400
d[4] = 825741337280

```
5. 指针的指针
如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。
声明如下:
`var ptr **int`

简单使有:

```
/*指针变量*/
var k int
var ptr1 *int
var ptr2 **int

k = 3000
ptr1 = &k
ptr2 = &ptr1
/*获取上面的*/
fmt.Printf("变量 k = %d\n", k)
fmt.Printf("指针变量 *ptr1 = %d\n", *ptr1)
fmt.Println("指针与指针变量的地址", ptr1, ptr2, *ptr2)
fmt.Printf("指向指针的指针变量 **ptr2 = %d\n", **ptr2)
```
结果如下:
```
变量 k = 3000
指针变量 *ptr1 = 3000
指针与指针变量的地址 0xc042042338 0xc04205a028 0xc042042338
指向指针的指针变量 **ptr2 = 3000
```
6. 指针作为函数参数

```
/*参数*/
x := 100
y := 200
fmt.Printf("交换前x=%d,y=%d\n", x, y)
swap(&x, &y)
fmt.Printf("交换后x=%d,y=%d\n", x, y)
```
结果:

```
交换前x=100,y=200
交换后x=200,y=100
```
